"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcapstone2_kanban"] = self["webpackChunkcapstone2_kanban"] || []).push([["methods"],{

/***/ "./src/modules/APIsGET&POST.js":
/*!*************************************!*\
  !*** ./src/modules/APIsGET&POST.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkAPI\": () => (/* binding */ checkAPI),\n/* harmony export */   \"getAnime\": () => (/* binding */ getAnime),\n/* harmony export */   \"getComments\": () => (/* binding */ getComments),\n/* harmony export */   \"getLikes\": () => (/* binding */ getLikes),\n/* harmony export */   \"postComments\": () => (/* binding */ postComments),\n/* harmony export */   \"postLikes\": () => (/* binding */ postLikes)\n/* harmony export */ });\nconst getAnime = async (url) => {\n  // If URL contains 'jikan.moe' it's a public API; fetch without special headers\n  try {\n    const response = await fetch(url, { method: 'GET' });\n    return await response.json();\n  } catch (err) {\n    console.warn('getAnime fetch failed', err);\n    throw err;\n  }\n};\n\n// Lightweight health-check with timeout to confirm public API availability\nasync function checkAPI(url, timeout = 3000) {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n  try {\n    const res = await fetch(url, { method: 'GET', signal: controller.signal });\n    clearTimeout(id);\n    return res.ok;\n  } catch (err) {\n    clearTimeout(id);\n    return false;\n  }\n}\n\nconst getLikes = async (url) => {\n  const response = await fetch(url).then((res) => res.json());\n  return response;\n};\n\nasync function getComments(url) {\n  const response = await fetch(url).then((res) => res.json());\n  return response;\n}\n\nconst postComments = async (id, username, comment, url) => {\n  await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      item_id: id,\n      username,\n      comment,\n    }),\n  });\n};\n\nconst postLikes = async (id, url) => {\n  await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      item_id: id,\n    }),\n  });\n};\n\n\n//# sourceURL=webpack://capstone2-kanban/./src/modules/APIsGET&POST.js?");

/***/ }),

/***/ "./src/modules/methods.js":
/*!********************************!*\
  !*** ./src/modules/methods.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Methods)\n/* harmony export */ });\n/* harmony import */ var _APIsGET_POST_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./APIsGET&POST.js */ \"./src/modules/APIsGET&POST.js\");\n/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalize.js */ \"./src/modules/normalize.js\");\n\n\n\nclass Methods {\n  constructor() {\n    this.animes = [];\n  }\n\n  // stable key for a comment so we can persist locally deleted entries\n  static commentKey(index, username, creationDate, comment) {\n    return `${index}::${(username||'').toString().trim()}::${(creationDate||'').toString().trim()}::${(comment||'').toString().trim()}`;\n  }\n\n  // options: { append: boolean }\n  async loadData(movieList, animeAPI, likesAPI, options = {}) {\n    const append = options.append === true;\n    // reset previous render unless appending\n    if (!append) {\n      if (movieList && movieList.innerHTML) movieList.innerHTML = '';\n      this.animes = [];\n    }\n\n    // getAnime should return an array of items; Jikan returns { data: [...] }\n    let list = [];\n    try {\n      list = await (0,_APIsGET_POST_js__WEBPACK_IMPORTED_MODULE_0__.getAnime)(animeAPI);\n      if (list && list.data && Array.isArray(list.data)) list = list.data;\n      if (!Array.isArray(list)) list = [];\n    } catch (err) {\n      console.warn('Failed to fetch anime list', err);\n      list = [];\n    }\n\n    // Fallback sample data (small) to ensure UI has something to render\n    if (!list || list.length === 0) {\n      list = [\n        {\n          title: 'Sample: Skybound Saga',\n          images: { jpg: { image_url: './icons&imgs/dynasty-logo.svg' } },\n          synopsis: 'A thrilling adventure about sky pirates and ancient machines.',\n          genres: [{ name: 'Action' }, { name: 'Adventure' }],\n          rank: null,\n        },\n        {\n          title: 'Sample: Night Blossom',\n          images: { jpg: { image_url: './icons&imgs/dynasty-logo.svg' } },\n          synopsis: 'A quiet story of love and secrets in a coastal town.',\n          genres: [{ name: 'Drama' }, { name: 'Romance' }],\n          rank: null,\n        },\n      ];\n    }\n\n    let likes = [];\n    try {\n      likes = await (0,_APIsGET_POST_js__WEBPACK_IMPORTED_MODULE_0__.getLikes)(likesAPI);\n      if (!Array.isArray(likes)) likes = [];\n    } catch (err) {\n      // likes are optional - continue without them\n      console.warn('Failed to fetch likes', err);\n      likes = [];\n    }\n    // create a map for quick likes lookup by numeric item id\n    const likeMap = new Map();\n    likes.forEach((l) => { const id = Number(l.item_id); if (!Number.isNaN(id)) likeMap.set(id, l.likes); });\n  // batch DOM updates into a fragment for better performance\n  const frag = document.createDocumentFragment();\n  list.forEach((anime, i) => {\n      // ensure anime exists\n      if (!anime) return;\n      const baseIndex = this.animes.length;\n      const globalIndex = baseIndex + i;\n      // normalize additional fields for richer UI using shared helper\n      const norm = (0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalizeAnime)(anime) || {};\n      // compute sanitized synopsis before rendering so the card uses a short, cleaned excerpt\n  const cleanSynopsis = Methods.sanitizeSynopsis(norm.synopsis || '');\n\n      // Note: normalization for Jikan/API fields is handled above in the \"norm\" object\n  const div = document.createElement('div');\n      div.className =\n        'movie-card bg-gray-800 rounded-lg shadow-xl overflow-hidden transform hover:-translate-y-2 transition duration-300';\n      // if caller requests hidden append (prefetch), mark added cards so they stay hidden until revealed\n      if (options && options.hidden) div.classList.add('hidden-by-default');\n      div.dataset.id = globalIndex;\n      // store title for client-side filtering\n  div.dataset.title = (anime.title || '').toLowerCase();\n\n  const liked = likeMap.get(globalIndex) || 0;\n\n  // build responsive srcset when available\n  const srcset = (0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.buildSrcSet)(norm.image, norm.imageHigh);\n  const srcsetAttr = srcset ? `srcset=\"${srcset}\" sizes=\"(max-width:800px)400px, 1200px\"` : '';\n\n      // richer card markup with poster wrap, play overlay and badges\n      div.innerHTML = `\n        <div class=\"card-inner\">\n            <div class=\"poster-wrap\">\n            <img loading=\"lazy\" decoding=\"async\" class=\"poster\" src=\"${norm.image}\" ${srcsetAttr} alt=\"${norm.title}\">\n            <div class=\"play-overlay\" aria-hidden=\"true\"><i class=\"fas fa-play\"></i></div>\n            <div class=\"badge\">${norm.ranking ? `#${norm.ranking}` : 'NEW'}</div>\n          </div>\n          <div class=\"meta\">\n            <h3 class=\"title\">${norm.title}</h3>\n            <div class=\"card-meta\">\n              <div class=\"sub\">${norm.genres ? norm.genres.join(', ').slice(0, 40) : ''}</div>\n              <div class=\"meta-right\" style=\"margin-left:auto; text-align:right; font-weight:700\">${norm.score ? `★ ${norm.score}` : ''}${norm.episodes ? ` · ${norm.episodes} ep` : ''}</div>\n              <div class=\"likes\"><span id=\"span-${globalIndex}\">${liked}</span> <i class=\"fas fa-heart\" style=\"opacity:0.6;margin-left:6px\"></i></div>\n            </div>\n            <div class=\"info-strip\">${cleanSynopsis ? (cleanSynopsis.length > 70 ? (cleanSynopsis.slice(0, 70) + '…') : cleanSynopsis) : ''}</div>\n            <div class=\"actions\">\n              <button class=\"icon-btn fav-btn\" aria-label=\"favorite\"><i class=\"fas fa-bookmark\"></i></button>\n              <button class=\"icon-btn like-btn\" aria-label=\"like\"><i class=\"fas fa-heart\"></i></button>\n              <button class=\"icon-btn comment-btn\" aria-label=\"comments\"><i class=\"fas fa-comment\"></i></button>\n            </div>\n          </div>\n        </div>`;\n      frag.appendChild(div);\n      const item = {\n        id: globalIndex,\n        title: norm.title,\n        synopsis: cleanSynopsis,\n        image: norm.image,\n        likes: liked,\n        mal_id: norm.mal_id,\n        score: norm.score,\n        episodes: norm.episodes,\n        trailer: norm.trailer,\n        comments: 0,\n      };\n      this.animes.push(item);\n      this.itemsCounter();\n    });\n    // attach all cards in one operation\n    if (movieList && frag.childNodes && frag.childNodes.length) movieList.appendChild(frag);\n    // return how many items were processed so callers can decide whether more pages exist\n    return list.length;\n  }\n\n  // remove typical \"written by\" attributions and trailing author credit lines\n  static sanitizeSynopsis(text) {\n    if (!text) return '';\n    // remove lines that start with 'Written by' or 'By' or 'Written:' or 'Source:' or '—'\n    const lines = text.split(/\\r?\\n/).map(l => l.trim());\n    const filtered = lines.filter((l) => {\n      const low = l.toLowerCase();\n      if (!l) return false;\n      if (low.startsWith('written by')) return false;\n      if (low.startsWith('by ')) return false;\n      if (low.startsWith('source:')) return false;\n      // some APIs include '— Author' or similar\n      if (/^—|^\\u2014/.test(l)) return false;\n      return true;\n    });\n    // also remove trailing 'Written by' fragments inside the last 100 chars\n    let joined = filtered.join(' ');\n    joined = joined.replace(/\\s*written by[\\s\\S]*$/i, '');\n    return joined.trim();\n  }\n\n  increaseLikes(index) {\n    const likeSpan = document.getElementById(`span-${index}`);\n    this.animes[index].likes += 1;\n    likeSpan.innerText = this.animes[index].likes;\n  }\n\n  itemsCounter() {\n    const animesNum = document.getElementById('animesNum');\n    animesNum.innerText = this.animes.length;\n  }\n\n  async loadModalInfo(index, commentsAPI) {\n    const anime = this.animes[index];\n    // don't reset comments prematurely; we'll update after fetching existing comments\n    const commentsNumEl = document.getElementById('commentsNumber');\n    if (commentsNumEl) commentsNumEl.innerText = this.animes[index].comments || 0;\n    const description = document.getElementById('animeDescription');\n    const raw = anime.synopsis || 'No description provided.';\n    // render with read-more if too long (use instance method)\n    if (description) this.renderWithReadMore(description, raw, 400);\n    document.getElementById('modal-title').innerText = anime.title;\n    document.getElementById('modal-image').setAttribute('src', anime.image);\n    // add trailer embed (YouTube iframe) or fallback link if available\n    const existingTrailerWrap = document.getElementById('trailer-wrap');\n    if (existingTrailerWrap && existingTrailerWrap.parentNode) existingTrailerWrap.parentNode.removeChild(existingTrailerWrap);\n    if (anime.trailer) {\n      const right = document.querySelector('.modal-inner .right');\n      if (right) {\n        const trailerWrap = document.createElement('div');\n        trailerWrap.id = 'trailer-wrap';\n        trailerWrap.className = 'trailer-wrap';\n\n        // try to detect YouTube video id and embed; otherwise provide a safe external link\n        let ytId = null;\n        try {\n          const parsed = new URL(anime.trailer);\n          if (parsed.hostname.includes('youtube.com')) ytId = parsed.searchParams.get('v');\n          if (parsed.hostname.includes('youtu.be')) ytId = parsed.pathname.replace(/^\\//, '');\n        } catch (e) {\n          // fallback regex\n          const m = String(anime.trailer).match(/[?&]v=([^&]+)/);\n          if (m) ytId = m[1];\n          const m2 = String(anime.trailer).match(/youtu\\.be\\/(.+)$/);\n          if (!ytId && m2) ytId = m2[1];\n        }\n\n        if (ytId) {\n          const iframe = document.createElement('iframe');\n          iframe.setAttribute('src', `https://www.youtube.com/embed/${ytId}?rel=0`);\n          iframe.setAttribute('title', `${anime.title} — trailer`);\n          iframe.setAttribute('frameborder', '0');\n          iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');\n          iframe.setAttribute('allowfullscreen', '');\n          iframe.className = 'trailer-iframe';\n          trailerWrap.appendChild(iframe);\n        } else {\n          const link = document.createElement('a');\n          link.id = 'watch-trailer';\n          link.className = 'cta';\n          link.href = anime.trailer;\n          link.target = '_blank';\n          link.rel = 'noopener noreferrer';\n          link.innerText = 'Watch trailer';\n          trailerWrap.appendChild(link);\n        }\n\n        right.insertBefore(trailerWrap, right.querySelector('div'));\n      }\n    }\n    // When modal image loads, add loaded class for sticker animation\n    const modalImg = document.getElementById('modal-image');\n    if (modalImg) {\n      if (modalImg.complete) modalImg.classList.add('loaded');\n      else modalImg.addEventListener('load', () => modalImg.classList.add('loaded'));\n    }\n  const badge = document.getElementById('sticker-badge');\n  if (badge) badge.innerText = anime.title.length > 28 ? `${anime.title.slice(0, 25)}…` : anime.title;\n    const comments = document.getElementById('comments');\n    comments.dataset.id = index;\n    comments.innerHTML = '';\n    const commentsURL = `${commentsAPI}?item_id=${index}`;\n    const commentsArray = await (0,_APIsGET_POST_js__WEBPACK_IMPORTED_MODULE_0__.getComments)(commentsURL);\n    if (Array.isArray(commentsArray)) {\n      // load locally-deleted keys from storage\n      const deleted = JSON.parse(localStorage.getItem('deletedComments') || '[]');\n      // filter out comments that were deleted locally\n      const filtered = commentsArray.filter((c) => {\n        const key = Methods.commentKey(index, c.username, c.creation_date, c.comment);\n        return !deleted.includes(key);\n      });\n      // reflect filtered count\n      this.animes[index].comments = filtered.length;\n      if (commentsNumEl) commentsNumEl.innerText = this.animes[index].comments;\n      filtered.forEach((comment) => {\n        this.addComment(\n          index,\n          comment.username,\n          comment.creation_date,\n          comment.comment,\n        );\n      });\n    }\n  }\n\n    renderWithReadMore(container, text, maxChars = 300) {\n      // clear\n      container.innerHTML = '';\n      const short = text.slice(0, maxChars);\n      const needsToggle = text.length > maxChars;\n\n      const body = document.createElement('div');\n      body.className = 'anime-desc-body';\n      body.textContent = needsToggle ? short + '…' : text;\n\n      if (!needsToggle) body.classList.add('expanded');\n\n      container.appendChild(body);\n\n      if (needsToggle) {\n        const btn = document.createElement('button');\n        btn.type = 'button';\n        btn.className = 'read-more-btn';\n        btn.setAttribute('aria-expanded', 'false');\n        btn.textContent = 'Read more';\n\n        btn.addEventListener('click', () => {\n          const expanded = btn.getAttribute('aria-expanded') === 'true';\n          if (expanded) {\n            body.textContent = short + '…';\n            body.classList.remove('expanded');\n            btn.textContent = 'Read more';\n            btn.setAttribute('aria-expanded', 'false');\n          } else {\n            body.textContent = text;\n            body.classList.add('expanded');\n            btn.textContent = 'Show less';\n            btn.setAttribute('aria-expanded', 'true');\n          }\n          // announce visually for screen readers via aria-live container if present\n          const live = container.querySelector('[aria-live]');\n          if (live) live.textContent = btn.textContent + ' description';\n        });\n\n        container.appendChild(btn);\n      }\n    }\n  addComment(index, username, creationDate, comment) {\n    const div = document.createElement('div');\n    const comments = document.getElementById('comments')\n      || document.querySelector('.comments')\n      || (() => {\n        const el = document.createElement('div');\n        el.id = 'comments';\n        document.body.appendChild(el);\n        return el;\n      })();\n    const commentsNum = document.getElementById('commentsNumber');\n    div.className = 'comment';\n    // Add a data attribute for identification (optional) and include a close button\n    div.setAttribute('data-author', username);\n    div.innerHTML = `\n      <div style=\"display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:8px\">\n        <div style=\"display:flex; gap:12px; align-items:center\">\n          <div class=\"avatar\">${(username && username[0]) ? username[0].toUpperCase() : 'U'}</div>\n          <div>\n            <div class=\"comment-meta\"><strong>${username}</strong> <span style=\"color:var(--muted); font-size:0.85rem; margin-left:8px\">${creationDate}</span></div>\n          </div>\n        </div>\n        <button class=\"comment-close\" aria-label=\"Delete comment\" title=\"Delete comment\">&times;</button>\n      </div>\n      <p>${comment}</p>\n    `;\n    this.animes[index].comments += 1;\n    commentsNum.innerText = this.animes[index].comments;\n    comments.appendChild(div);\n    // Wire the close button to show a small inline confirm box before deleting\n    const closeBtn = div.querySelector('.comment-close');\n    if (closeBtn) {\n      closeBtn.addEventListener('click', () => {\n        // prevent duplicate confirm boxes\n        if (div.querySelector('.confirm-box')) return;\n        const confirmBox = document.createElement('div');\n        confirmBox.className = 'confirm-box';\n        confirmBox.innerHTML = `\n          <span>Delete this comment?</span>\n          <div class=\"confirm-actions\">\n            <button class=\"confirm-yes\">Delete</button>\n            <button class=\"confirm-no\">Cancel</button>\n          </div>\n        `;\n        div.appendChild(confirmBox);\n\n        const yes = confirmBox.querySelector('.confirm-yes');\n        const no = confirmBox.querySelector('.confirm-no');\n\n        // Focus the confirm button for keyboard users\n        if (yes && typeof yes.focus === 'function') yes.focus();\n\n        yes.addEventListener('click', () => {\n          // persist deletion locally so it doesn't reappear on reload\n          const key = Methods.commentKey(index, username, creationDate, comment);\n          const deleted = JSON.parse(localStorage.getItem('deletedComments') || '[]');\n          if (!deleted.includes(key)) {\n            deleted.push(key);\n            localStorage.setItem('deletedComments', JSON.stringify(deleted));\n          }\n          // animate removal\n          div.classList.add('removing');\n          setTimeout(() => {\n            if (div && div.parentNode) div.parentNode.removeChild(div);\n            // update internal count and UI\n            if (typeof this.animes[index].comments === 'number' && this.animes[index].comments > 0) {\n              this.animes[index].comments -= 1;\n              commentsNum.innerText = this.animes[index].comments;\n            }\n            // cleanup confirm box if still present\n            if (confirmBox && confirmBox.parentNode) confirmBox.parentNode.removeChild(confirmBox);\n          }, 320);\n        });\n\n        no.addEventListener('click', () => {\n          if (confirmBox && confirmBox.parentNode) confirmBox.parentNode.removeChild(confirmBox);\n          // return focus to close button\n          if (closeBtn && typeof closeBtn.focus === 'function') closeBtn.focus();\n        });\n      });\n    }\n    // entrance animation for new comment\n    requestAnimationFrame(() => {\n      div.classList.add('enter');\n      requestAnimationFrame(() => div.classList.add('show'));\n    });\n  }\n\n  async addNewComment(commentsAPI) {\n    const username = document.getElementById('InputName');\n    const comment = document.getElementById('commentToPost');\n    const small = document.getElementById('small');\n    if (!username || !comment) return;\n    // basic validation\n    if (!username.value.trim() || !comment.value.trim()) {\n      if (small) small.classList.remove('hidden');\n      return;\n    }\n    if (small) small.classList.add('hidden');\n    let container = document.getElementById('comments') || document.querySelector('.comments');\n    if (!container) {\n      container = document.createElement('div');\n      container.id = 'comments';\n      container.dataset.id = 0;\n      document.body.appendChild(container);\n    }\n    const index = container.dataset.id;\n    const currentDate = new Date();\n    const month = String(currentDate.getMonth() + 1).padStart(2, '0');\n    const day = String(currentDate.getDate()).padStart(2, '0');\n    const url = `${commentsAPI}`;\n    await (0,_APIsGET_POST_js__WEBPACK_IMPORTED_MODULE_0__.postComments)(index, username.value, comment.value, url);\n    this.addComment(\n      index,\n      username.value,\n      `${currentDate.getFullYear()}-${month}-${day}`,\n      comment.value,\n    );\n    username.value = '';\n    comment.value = '';\n  }\n}\n\n\n//# sourceURL=webpack://capstone2-kanban/./src/modules/methods.js?");

/***/ }),

/***/ "./src/modules/normalize.js":
/*!**********************************!*\
  !*** ./src/modules/normalize.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildSrcSet\": () => (/* binding */ buildSrcSet),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"normalizeAnime\": () => (/* binding */ normalizeAnime)\n/* harmony export */ });\n// Normalization helpers for anime items (Jikan API)\nfunction normalizeAnime(anime) {\n  if (!anime) return null;\n  const title = anime.title || (anime.titles && anime.titles[0] && anime.titles[0].title) || 'Untitled';\n  const image = (anime.images && anime.images.jpg && (anime.images.jpg.image_url || anime.images.jpg.large_image_url)) || anime.image || './icons&imgs/dynasty-logo.svg';\n  const imageHigh = (anime.images && anime.images.jpg && (anime.images.jpg.large_image_url || anime.images.jpg.image_url)) || anime.image || './icons&imgs/dynasty-logo.svg';\n  const synopsis = anime.synopsis || anime.background || '';\n  const genres = (anime.genres && anime.genres.map(g => g.name)) || (anime.genres_list && anime.genres_list.map(g => g.name)) || [];\n  const ranking = anime.rank || anime.ranking || null;\n  const mal_id = anime.mal_id || anime.id || null;\n  const score = anime.score || null;\n  const episodes = anime.episodes || null;\n  const trailer = (anime.trailer && (anime.trailer.youtube_id ? `https://www.youtube.com/watch?v=${anime.trailer.youtube_id}` : anime.trailer.url)) || null;\n  return { title, image, imageHigh, synopsis, genres, ranking, mal_id, score, episodes, trailer };\n}\n\n// Build a conservative srcset string for responsive images\nfunction buildSrcSet(image, imageHigh) {\n  // If both are identical or missing, return single src\n  if (!imageHigh || imageHigh === image) return null;\n  // simple heuristic: provide two sizes\n  return `${image} 400w, ${imageHigh} 1200w`;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ normalizeAnime, buildSrcSet });\n\n\n//# sourceURL=webpack://capstone2-kanban/./src/modules/normalize.js?");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/modules/methods.js"));
/******/ }
]);